// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: wallets.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addOperation = `-- name: AddOperation :exec
INSERT INTO operations (id, wallet_id, operation_type, amount)
VALUES (
	gen_random_uuid(),
	$1,
	$2,
	$3
)
`

type AddOperationParams struct {
	WalletID      pgtype.UUID `json:"wallet_id"`
	OperationType string      `json:"operation_type"`
	Amount        int32       `json:"amount"`
}

func (q *Queries) AddOperation(ctx context.Context, arg AddOperationParams) error {
	_, err := q.db.Exec(ctx, addOperation, arg.WalletID, arg.OperationType, arg.Amount)
	return err
}

const createWallet = `-- name: CreateWallet :one
INSERT INTO wallets (id)
VALUES (
	gen_random_uuid()
)
RETURNING id
`

func (q *Queries) CreateWallet(ctx context.Context) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createWallet)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteWallet = `-- name: DeleteWallet :exec
DELETE FROM wallets WHERE id = $1
`

func (q *Queries) DeleteWallet(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteWallet, id)
	return err
}

const getBalance = `-- name: GetBalance :one
SELECT balance FROM wallets 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetBalance(ctx context.Context, id pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getBalance, id)
	var balance int32
	err := row.Scan(&balance)
	return balance, err
}

const getWallets = `-- name: GetWallets :many
SELECT id, balance, created_at, updated_at FROM wallets ORDER BY created_at
`

func (q *Queries) GetWallets(ctx context.Context) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getWallets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.Balance,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWallet = `-- name: UpdateWallet :exec
UPDATE wallets SET balance = $1, updated_at = NOW()
WHERE id = $2
`

type UpdateWalletParams struct {
	Balance int32       `json:"balance"`
	ID      pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateWallet(ctx context.Context, arg UpdateWalletParams) error {
	_, err := q.db.Exec(ctx, updateWallet, arg.Balance, arg.ID)
	return err
}
